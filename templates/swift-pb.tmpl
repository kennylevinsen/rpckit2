import Foundation

{{/*                               */ -}}
{{/* Begin write protocol handling */ -}}
{{/*                               */ -}}

enum RPCError: Error {
	case eof
	case protocolError
	case connectionError
	case applicationError(String)
}

enum RPCErrorType: UInt64 {
	case generic = 0
	case timeout = 1
	case proto = 2
	case application = 3
	case connection = 4
	case shutdown = 5
}

enum RPCWireType: UInt64 {
	case varInt = 0
	case fixed64Bit = 1
	case lengthDelimited = 2
	case fixed32Bit = 5
}

enum RPCMessageType: UInt64 {
	case methodCall = 1
	case methodReturn = 2
}

class readableMessage {
	var pos: Int = 0
	var len: Int = 0
	var buf: ArraySlice<UInt8>

	init?(slice: ArraySlice<UInt8>) {
		if (slice.count <= 4) {
			return nil
		}
		self.buf = slice
		self.pos = slice.startIndex + 4
		self.len = Int( Data(slice[slice.startIndex..<slice.startIndex+4]).withUnsafeBytes { $0.load(as: UInt32.self) }.bigEndian )
	}

	init(embeddedSlice: ArraySlice<UInt8>) {
		self.buf = embeddedSlice
		self.len = self.buf.startIndex + buf.count
		self.pos = self.buf.startIndex
	}

	func readBytes() -> Result<ArraySlice<UInt8>, RPCError> {
		var len: Int
		switch self.readVarUInt() {
		case .success(let val):
			len = Int(val)
		case .failure(let error):
			return .failure(error)
		}

		if self.pos + len > self.len {
			return .failure(RPCError.eof)
		}
		let slice = self.buf[self.pos ..< self.pos + len]
		self.pos += len
		return .success(slice)
	}

	func readString() -> Result<String, RPCError> {
		switch self.readBytes() {
		case .success(let val):
			if let string = String(data: Data(val), encoding: .utf8) {
				return .success(string)
			} else {
				return .failure(RPCError.protocolError)
			}
		case .failure(let error):
			return .failure(error)
		}
	}

	func readEmbeddedMessage() -> Result<readableMessage, RPCError> {
		switch self.readBytes() {
		case .success(let val):
			return .success(readableMessage(embeddedSlice: val))
		case .failure(let error):
			return .failure(error)
		}
	}

	func readVarUInt() -> Result<UInt64, RPCError> {
		var x: UInt64 = 0
		var s: UInt = 0
		for index in 0..<self.len {
			if self.pos+1 > self.len {
				return .failure(RPCError.eof)
			}
			let b = self.buf[self.pos]
			self.pos += 1
			if b < 0x80 {
				if index > 9 || (index == 9 && b > 1) {
					return .failure(RPCError.protocolError)
				}
				return .success(x | UInt64(b) << s)
			}
			x |= UInt64(b & 0x7F) << s
			s += 7
		}
		return .failure(RPCError.protocolError)
	}

	func readVarInt() -> Result<Int64, RPCError> {
		switch self.readVarUInt() {
		case .success(let val):
			return .success(Int64(val))
		case .failure(let error):
			return .failure(error)
		}
	}

	func readInt() -> Result<Int64, RPCError> {
		return self.readVarInt()
	}

	func readUInt32() -> Result<UInt32, RPCError> {
		if self.pos + 4 > self.len {
			return .failure(RPCError.eof)
		}
		let val = Data(self.buf[self.pos..<self.pos+4]).withUnsafeBytes { $0.load(as: UInt32.self) }
		self.pos += 4
		return .success(val)
	}

	func readUInt64() -> Result<UInt64, RPCError> {
		if self.pos + 8 > self.len {
			return .failure(RPCError.eof)
		}
		let val = Data(self.buf[self.pos..<self.pos+8]).withUnsafeBytes { $0.load(as: UInt64.self) }
		self.pos += 8
		return .success(val)
	}

	func readInt32() -> Result<Int32, RPCError> {
		switch self.readUInt32() {
		case .success(let val):
			return .success(Int32(val))
		case .failure(let error):
			return .failure(error)
		}
	}

	func readInt64() -> Result<Int64, RPCError> {
		switch self.readUInt64() {
		case .success(let val):
			return .success(Int64(val))
		case .failure(let error):
			return .failure(error)
		}
	}

	func readBool() -> Result<Bool, RPCError> {
		switch self.readVarUInt() {
		case .success(let val):
			return .success(val == 1)
		case .failure(let error):
			return .failure(error)
		}
	}

	func readFloat() -> Result<Float, RPCError> {
		if self.pos + 4 > self.len {
			return .failure(RPCError.eof)
		}
		let val = Data(self.buf[self.pos..<self.pos+4]).withUnsafeBytes { $0.load(as: Float.self) }
		self.pos += 4
		return .success(val)
	}

	func readDouble() -> Result<Double, RPCError> {
		if self.pos + 8 > self.len {
			return .failure(RPCError.eof)
		}
		let val = Data(self.buf[self.pos..<self.pos+8]).withUnsafeBytes { $0.load(as: Double.self) }
		self.pos += 8
		return .success(val)
	}

	func readPBSkip(tag: UInt64) -> Result<Void, RPCError> {
		guard let t = RPCWireType(rawValue: tag & ((1 << 3) - 1)) else {
			return .failure(RPCError.protocolError)
		}
		switch t {
		case RPCWireType.varInt:
			switch self.readVarUInt() {
			case .success(_):
				return .success(())
			case .failure(let error):
				return .failure(error)
			}
		case RPCWireType.fixed64Bit:
			switch self.readInt64() {
			case .success(_):
				return .success(())
			case .failure(let error):
				return .failure(error)
			}
		case RPCWireType.lengthDelimited:
			switch self.readBytes() {
			case .success(_):
				return .success(())
			case .failure(let error):
				return .failure(error)
			}
		case RPCWireType.fixed32Bit:
			switch self.readInt32() {
			case .success(_):
				return .success(())
			case .failure(let error):
				return .failure(error)
			}
		}
	}
}

class writableMessage {
	var buf: [UInt8] = []
	var embedded: Bool = false

	init() {
		self.buf.reserveCapacity(1024)
		for _ in 0..<4 {
			self.buf.append(0)
		}
	}

	init(embedded: Bool) {
		self.buf.reserveCapacity(1024)
		if !embedded {
			for _ in 0..<4 {
				self.buf.append(0)
			}
		}
	}

	init(capacity: Int) {
		self.buf.reserveCapacity(capacity)
		for _ in 0..<4 {
			self.buf.append(0)
		}
	}

	init(embeddedCapacity: Int) {
		self.buf.reserveCapacity(embeddedCapacity)
		self.embedded = true
	}

	func finish() {
		if !self.embedded {
			let data = Swift.withUnsafeBytes(of: UInt32(self.buf.count).bigEndian) { Data($0) }
			for idx in 0..<data.count {
				self.buf[idx] = data[idx]
			}
		}
	}

	func writeVarUInt(value: UInt64) {
		var v = value
		while v >= 0x80 {
			self.buf.append(UInt8(v & 0xFF) | 0x80)
			v >>= 7
		}
		self.buf.append(UInt8(v & 0xFF))
	}

	func writeVarInt(value: Int64) {
		return self.writeVarUInt(value: UInt64(value))
	}

	func writeBytes(bytes: ArraySlice<UInt8>) {
		self.writeVarUInt(value: UInt64(bytes.count))
		for byte in bytes {
			self.buf.append(byte)
		}
	}

	func writeString(str: String) {
		let utf8 = str.utf8
		self.writeVarUInt(value: UInt64(utf8.count))
		for byte in utf8 {
			self.buf.append(byte)
		}
	}

	func writeSimple<T>(value: T) {
		let data = Swift.withUnsafeBytes(of: value) { Data($0) }
		for byte in data {
			self.buf.append(byte)
		}
	}

	func writePBTag(fieldNumber: UInt64, wt: RPCWireType) {
		self.writeVarUInt(value: (fieldNumber << 3) | wt.rawValue)
	}

	func writePBString(fieldNumber: UInt64, value: String) {
		if value.count > 0 {
			self.writePBTag(fieldNumber: fieldNumber, wt: RPCWireType.lengthDelimited)
			self.writeString(str: value)
		}
	}

	func writePBBytes(fieldNumber: UInt64, value: ArraySlice<UInt8>) {
		if value.count > 0 {
			self.writePBTag(fieldNumber: fieldNumber, wt: RPCWireType.lengthDelimited)
			self.writeBytes(bytes: value)
		}
	}

	func writePBBool(fieldNumber: UInt64, value: Bool) {
		if value {
			self.writePBTag(fieldNumber: fieldNumber, wt: RPCWireType.varInt)
			self.writeVarUInt(value: 1)
		}
	}

	func writePBVarUInt(fieldNumber: UInt64, value: UInt64) {
		if value != 0 {
			self.writePBTag(fieldNumber: fieldNumber, wt: RPCWireType.varInt)
			self.writeVarUInt(value: value)
		}
	}

	func writePBVarInt(fieldNumber: UInt64, value: Int64) {
		if value != 0 {
			self.writePBTag(fieldNumber: fieldNumber, wt: RPCWireType.varInt)
			self.writeVarInt(value: value)
		}
	}

	func writePBInt(fieldNumber: UInt64, value: Int64) {
		return self.writePBVarInt(fieldNumber: fieldNumber, value: value)
	}

	func writePBInt64(fieldNumber: UInt64, value: Int64) {
		if value != 0 {
			self.writePBTag(fieldNumber: fieldNumber, wt: RPCWireType.fixed64Bit)
			self.writeSimple(value: value)
		}
	}

	func writePBUInt64(fieldNumber: UInt64, value: UInt64) {
		if value != 0 {
			self.writePBTag(fieldNumber: fieldNumber, wt: RPCWireType.fixed64Bit)
			self.writeSimple(value: value)
		}
	}

	func writePBInt32(fieldNumber: UInt64, value: Int32) {
		if value != 0 {
			self.writePBTag(fieldNumber: fieldNumber, wt: RPCWireType.fixed32Bit)
			self.writeSimple(value: value)
		}
	}

	func writePBUInt64(fieldNumber: UInt64, value: UInt32) {
		if value != 0 {
			self.writePBTag(fieldNumber: fieldNumber, wt: RPCWireType.fixed32Bit)
			self.writeSimple(value: value)
		}
	}

	func writePBFloat(fieldNumber: UInt64, value: Float) {
		if value != 0.0 {
			self.writePBTag(fieldNumber: fieldNumber, wt: RPCWireType.fixed32Bit)
			self.writeSimple(value: value)
		}
	}

	func writePBDouble(fieldNumber: UInt64, value: Double) {
		if value != 0.0 {
			self.writePBTag(fieldNumber: fieldNumber, wt: RPCWireType.fixed64Bit)
			self.writeSimple(value: value)
		}
	}

	func writePBMessage(fieldNumber: UInt64, msg: writableMessage) {
		self.writePBBytes(fieldNumber: fieldNumber, value: msg.buf[...])
	}
}

protocol RPCMessage {
	func encode(_: writableMessage) -> Result<Void, RPCError>
	static func decode(_: readableMessage) -> Result<RPCMessage, RPCError>
	func id() -> UInt64
}

protocol RPCCallServer {
	func id() -> UInt64
	func handle(methodID: UInt64, rmsg: readableMessage) -> Result<RPCMessage, RPCError>;
}

fileprivate class callSlot {
	let callback: (readableMessage) -> Result<Void, RPCError>

	init(callback: @escaping (readableMessage) -> Result<Void, RPCError>) {
		self.callback = callback
	}
}

fileprivate enum rpcConnectionState {
	case disconnected
	case connecting
	case connected
}

fileprivate enum rpcReaderState {
	case readingPreamble
	case readingHeader
	case readingBody
}

class RPCConnection: NSObject, StreamDelegate {
	// Protocol state
	private var nextID: UInt64 = 0
	private var slots: [UInt64: callSlot] = [:]

	// Immutable paramters
	private let host: String
	private let port: Int
	private let tls: Bool
	private let servers: [UInt64 : RPCCallServer]

	// Connection
	fileprivate var connectionState: rpcConnectionState
	private var inputStream: InputStream!
	private var outputStream: OutputStream!

	private var readState: rpcReaderState
	private var readNeeds: Int
	private var readPos: Int
	private var readBuffer: [UInt8]

	private var writeBuffer: [UInt8]
	private var disconnectHook: (RPCConnection) -> ()

	init(host: String, port: Int, tls: Bool, servers: [RPCCallServer], disconnectHook: @escaping (RPCConnection) -> ()) {
		self.host = host
		self.port = port
		self.tls = tls
		self.connectionState = rpcConnectionState.disconnected

		self.readState = rpcReaderState.readingPreamble
		self.readNeeds = 10
		self.readPos = 0
		self.readBuffer = Array(repeating: 0, count: 1024)
		self.writeBuffer = []
		var smap: [UInt64 : RPCCallServer] = [:]
		for server in servers {
			smap[server.id()] = server
		}
		self.servers = smap
		self.disconnectHook = disconnectHook
	}

	func connect() {
		if self.connectionState != .disconnected {
			return
		}

		self.writeBuffer = [82, 80, 67, 75, 73, 84, 0, 0, 0, 1]
		self.writeBuffer.reserveCapacity(1024)
		self.connectionState = .connecting
		self.readState = rpcReaderState.readingPreamble
		self.readNeeds = 10

		var readStream: Unmanaged<CFReadStream>?
		var writeStream: Unmanaged<CFWriteStream>?

		CFStreamCreatePairWithSocketToHost(kCFAllocatorDefault,
										   self.host as CFString,
										   UInt32(self.port),
										   &readStream,
										   &writeStream)

		self.inputStream = readStream!.takeRetainedValue()
		self.outputStream = writeStream!.takeRetainedValue()

		if self.tls {
			// Enable SSL/TLS on the streams
			self.inputStream!.setProperty(kCFStreamSocketSecurityLevelNegotiatedSSL,
					forKey: Stream.PropertyKey.socketSecurityLevelKey)
			self.outputStream!.setProperty(kCFStreamSocketSecurityLevelNegotiatedSSL,
					forKey: Stream.PropertyKey.socketSecurityLevelKey)

			// Set the SSL/TLS settingson the streams
			let sslSettings: [NSString: Any] = [NSString(format: kCFStreamSSLIsServer): kCFBooleanFalse as Any]
			self.inputStream!.setProperty(sslSettings,
					forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
			self.outputStream!.setProperty(sslSettings,
					forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
		}

		self.inputStream.delegate = self
		self.outputStream.delegate = self

		self.inputStream.schedule(in: .main, forMode: .common)
		self.outputStream.schedule(in: .main, forMode: .common)

		self.inputStream.open()
		self.outputStream.open()
	}

	func disconnect() {
		if self.connectionState == .connected || self.connectionState == .connecting {
			self.connectionState = .disconnected
			self.inputStream.remove(from: .main, forMode: .common)
			self.outputStream.remove(from: .main, forMode: .common)
			self.inputStream.close()
			self.outputStream.close()
			self.inputStream.delegate = nil
			self.outputStream.delegate = nil
			self.inputStream = nil
			self.outputStream = nil
			self.writeBuffer.removeAll()
			self.disconnectHook(self)
		}
	}

	fileprivate func acquireCallSlot(callback: @escaping (readableMessage) -> Result<Void, RPCError>) -> UInt64 {
		var n: UInt64 = 0
		var taken = true
		while taken {
			n = self.nextID
			self.nextID += 1
			taken = self.slots[n] != nil
		}
		let slot = callSlot(callback: callback)
		self.slots[n] = slot
		return n
	}

	fileprivate func findAndReleaseCallSlot(id: UInt64) -> callSlot? {
		return self.slots.removeValue(forKey: id)
	}

	fileprivate func send(wmsg: writableMessage) {
		self.writeBuffer.append(contentsOf: wmsg.buf)
		self.flushWriteBuffer(stream: self.outputStream)
	}

	fileprivate func hasBytesAvailable(stream: InputStream) {
		// This routine implements a simple, singular message buffer. First a
		// header is read, then the body, then the positions are cleared.
		//
		// This design is simple, but causes excessive read calls. The most
		// efficient design by far would be a ring-buffer, possibly with
		// scaling for when a message that would exceed the buffer space is
		// detected. In second-place is a big-buffer design where data is moved
		// back every time a message is handled.
		//
		// Anyway, back to the video.
		while stream.hasBytesAvailable {
			while self.readPos + self.readNeeds > self.readBuffer.count {
				// This is a dumb way to grow an array.
				self.readBuffer.append(contentsOf: Data(repeating: 0, count: self.readBuffer.count))
			}

			let read = self.readBuffer.withUnsafeMutableBytes { ptr -> Int in
				let posptr = ptr.baseAddress!             // Get a raw pointer
					.assumingMemoryBound(to: UInt8.self)  // Make it a UInt8 pointer
					.advanced(by: self.readPos)           // Move it self.readPos bytes forward
				return stream.read(posptr, maxLength: self.readNeeds - self.readPos)
			}

			self.readPos += read

			if self.readPos < self.readNeeds {
				continue
			}

			switch self.readState {
			case .readingPreamble:
				self.readPos = 0
				self.readNeeds = 4
				self.readState = .readingHeader
				if (self.readBuffer[0..<10] != [82, 80, 67, 75, 73, 84, 0, 0, 0, 1]) {
					self.disconnect()
				}
				break
			case .readingHeader:
				// TODO: Check if the endianness is correct here.
				let header = Data(self.readBuffer[0..<4])
				let size = Int(header.withUnsafeBytes { $0.load(as: UInt32.self) }.bigEndian)
				self.readNeeds = size
				self.readState = .readingBody
				break
			case .readingBody:
				// This is terrible. This does a copy. We'll need to use a
				// native array to be able to get an ArraySlice, but that makes
				// the pointer part really ugly...
				let header = Data(self.readBuffer[0..<4])
				let size = Int(header.withUnsafeBytes { $0.load(as: UInt32.self) }.bigEndian)
				let message = readableMessage(slice: self.readBuffer[..<size])!
				self.readPos = 0
				self.readNeeds = 4
				self.readState = .readingHeader
				if case .failure(_) = self.gotMessage(msg: message) {
					self.disconnect()
				}
				break
			}
		}
	}

	fileprivate func flushWriteBuffer(stream: OutputStream) {
		// Just like the case with hasBytesAvailable, the buffer management
		// here is simple but dumb.
		if self.writeBuffer.count == 0 || self.connectionState != .connected {
			return
		}
		let cnt = self.writeBuffer.count;
		let written = self.writeBuffer.withUnsafeMutableBytes { ptr -> Int in
			let posptr = ptr.baseAddress!             // Get a raw pointer
				.assumingMemoryBound(to: UInt8.self)  // Make it a UInt8 pointer
			return stream.write(posptr, maxLength: cnt)
		}
		if written == -1 {
			self.disconnect()
		} else if written > 0 {
			self.writeBuffer.removeFirst(written)
		}
	}

	func stream(_ aStream: Stream, handle eventCode: Stream.Event) {
		switch eventCode {
		case Stream.Event.openCompleted:
			self.connectionState = .connected
			break
		case Stream.Event.hasBytesAvailable:
			self.hasBytesAvailable(stream: aStream as! InputStream)
			break
		case Stream.Event.endEncountered:
			self.disconnect()
			break
		case Stream.Event.errorOccurred:
			self.disconnect()
			break
		case Stream.Event.hasSpaceAvailable:
			self.flushWriteBuffer(stream: aStream as! OutputStream)
			break
		default:
			break
		}
	}

	fileprivate func gotMessage(msg: readableMessage) -> Result<Void, RPCError> {
		do {
			let mtraw = try msg.readVarUInt().get()
			guard let mt = RPCMessageType(rawValue: mtraw) else {
				return .failure(RPCError.protocolError)
			}
			switch mt {
			case RPCMessageType.methodCall:
				let callID = try msg.readVarUInt().get();
				let protocolID = try msg.readVarUInt().get();
				let server = self.servers[protocolID]
				if server == nil {
					return .failure(RPCError.protocolError)
				}
				let methodID = try msg.readVarUInt().get();
				let resp = try server!.handle(methodID: methodID, rmsg: msg).get();

				let wmsg = writableMessage()
				wmsg.writeVarUInt(value: RPCMessageType.methodReturn.rawValue)
				wmsg.writeVarUInt(value: callID)
				wmsg.writeVarUInt(value: resp.id())
				if case .failure(let error) = resp.encode(wmsg) {
					return .failure(error)
				}
				wmsg.finish()

				self.send(wmsg: wmsg)
				return .success(())
			case RPCMessageType.methodReturn:
				let callID = try msg.readVarUInt().get();
				let callSlot = self.findAndReleaseCallSlot(id: callID)
				if callSlot == nil {
					return .failure(RPCError.protocolError)
				}
				try callSlot!.callback(msg).get()
				return .success(())
			}
		} catch {
			return .failure(RPCError.protocolError)
		}
	}
}



{{- /*             */ -}}
{{- /* Utilitities */ -}}
{{- /*             */ -}}

{{ define "swift-pb/property-to-wiretype" -}}
{{- /* Internal rpckit to writetype constant converter */ -}}
{{- if eq . "String" -}}RPCWireType.lengthDelimited
{{- else if eq . "Bool" -}}RPCWireType.varInt
{{- else if eq . "Int64" -}}RPCWireType.fixed64Bit
{{- else if eq . "Int" -}}RPCWireType.varInt
{{- else if eq . "Float" -}}RPCWireType.fixed32Bit
{{- else if eq . "Double" -}}RPCWireType.fixed64Bit
{{- else if eq . "Bytes" }}RPCWireType.lengthDelimited
{{- else if eq . "Array" }}RPCWireType.lengthDelimited
{{- else if eq . "Map" }}RPCWireType.lengthDelimited
{{- else if eq . "Struct" }}RPCWireType.lengthDelimited
{{- else -}}{{ error . }}
{{- end -}}
{{ end }}



{{- /*                              */ -}}
{{- /* Per-protocol method ID enums */ -}}
{{- /*                              */ -}}

{{- range required .Protocols}}

{{ if ne (len .Methods) 0 -}}
fileprivate enum protocol{{ required .Name | capitalize }}Method: UInt64 {
	{{- range required .Methods }}
	case {{ .Name }} = {{ .ID }}
	{{- end }}
}
{{- end }}
{{- end }}



{{- /*                  */ -}}
{{- /* Type marshalling */ -}}
{{- /*                  */ -}}

{{- define "swift-pb/marshal-simple" -}}
{{- /* Marshal simple values, such as string, int and bool */ -}}
{{ required .Message }}.writePB{{ required .Field.String }}(fieldNumber: {{ required .ID }}, value: {{ required .Accessor }})
{{- end }}

{{- define "swift-pb/marshal-array" -}}
{{- /* Marshal array by calling marshal for each type */ -}}
for v in {{ required .Accessor }} {
	{{ template "swift-pb/marshal" dict "ID" .ID "Accessor" "v" "Message" $.Message "Field" .Field.InnerValue "ProtoName" .ProtoName }}
}
{{- end }}

{{ define "swift-pb/marshal-map" -}}
{{- /* Marshal map, using a custom encoder */ -}}
{{- $vname := retrieve (format "rpcMap-%s" .Field.SwiftType) -}}
for (key, value) in {{ required .Accessor }} {
	let em = writableMessage(embedded: true)
	let vs = {{ $vname }}(key, value)
	if case .failure(let error) = vs.encode(em) {
		return .failure(error)
	}
	{{ required .Message }}.writePBMessage(fieldNumber: {{ required .ID}}, msg: em)
}
{{ end }}

{{- define "swift-pb/marshal-struct" -}}
{{- /* Marshal struct, using custom encoder */ -}}
do {
	let em = writableMessage(embedded: true)
	let vs: rpcGlobalStruct{{ required .Field.SwiftType }} = rpcGlobalStruct{{ required .Field.SwiftType }}({{ required .Accessor }})
	if case .failure(let error) = vs.encode(em) {
		return .failure(error)
	}
	{{ required .Message }}.writePBMessage(fieldNumber: {{ required .ID}}, msg: em)
}
{{- end }}

{{- define "swift-pb/marshal" -}}
{{- /* Switch to check the type of the current field and dispatch to the proper marshaller */ -}}
{{- if .Field.IsStruct -}}{{- template "swift-pb/marshal-struct" . -}}
{{- else if .Field.IsMap -}}{{- template "swift-pb/marshal-map" . -}}
{{- else if .Field.IsArray -}}{{- template "swift-pb/marshal-array" . -}}
{{- else if .Field.IsMarshalled -}}{{- template "swift-pb/marshal-marshalled" . -}}
{{- else -}}{{- template "swift-pb/marshal-simple" . -}}
{{- end -}}
{{- end }}



{{- /*                    */ -}}
{{- /* Type unmarshalling */ -}}
{{- /*                    */ -}}

{{- define "swift-pb/unmarshal-simple" -}}
{{- /* Simple unmarshaller, handling types such as string, int and bool */ -}}
{{ required .Accessor }} = try {{ required .Message }}.read{{ required .Field.String }}().get()
{{- end }}

{{- define "swift-pb/unmarshal-array" -}}
{{- /* Array of types unmarshaller, calling unmarshal for each value */ -}}
let v: {{ required .Field.InnerValue.SwiftType }}
{{ template "swift-pb/unmarshal" dict "Field" .Field.InnerValue "Accessor" "v" "Message" $.Message "ProtoName" .ProtoName }}
{{ required .Accessor }}.append(v)
{{- end }}

{{ define "swift-pb/unmarshal-map" -}}
{{- /* Map<Type, Type>, handled by a custom struct decoder */ -}}
{{- $vname := retrieve (format "rpcMap-%s" .Field.SwiftType) -}}
let em = try {{ required .Message }}.readEmbeddedMessage().get()
switch {{ $vname }}.decode(em) {
case .success(let val):
	let x = val as! {{ $vname }}
	{{ required .Accessor }}[x.key] = x.value
case .failure(let error):
	return .failure(error)
}
{{ end }}

{{ define "swift-pb/unmarshal-struct" -}}
{{- /* Global struct, handled by a custom decoder */ -}}
let em = try {{ required .Message }}.readEmbeddedMessage().get()
switch rpcGlobalStruct{{ required .Field.SwiftType }}.decode(em) {
case .success(let val):
	{{ required .Accessor }} = (val as! rpcGlobalStruct{{ required .Field.SwiftType }}).v
case .failure(let error):
	return .failure(error)
}
{{ end }}

{{- define "swift-pb/unmarshal" -}}
{{- /* Switch to check the type of the current field and dispatch to the proper unmarshaller */ -}}
{{- if .Field.IsMap -}}{{- template "swift-pb/unmarshal-map" . -}}
{{- else if .Field.IsArray -}}{{- template "swift-pb/unmarshal-array" . -}}
{{- else if .Field.IsStruct -}}{{- template "swift-pb/unmarshal-struct" . -}}
{{- else if .Field.IsMarshalled -}}{{- template "swift-pb/unmarshal-marshalled" . -}}
{{- else -}}{{- template "swift-pb/unmarshal-simple" . -}}
{{- end -}}
{{- end }}



{{- /*                    */ -}}
{{- /* Server definitions */ -}}
{{- /*                    */ -}}

{{- range required .Protocols }}

// The {{ required .Name | capitalize }}Server protocol defines the {{ required .Name }} protocol.
protocol {{ required .Name | capitalize }}Server {
	{{- range required .Methods }}
	// {{ required .Description | capitalize }}
	func {{ required .Name | capitalize }}(
		{{- $input := required .Input -}}
		{{- range $idx, $v := required .Input }}{{ required $v.Name }}: {{ required $v.T.SwiftType }}{{- if ne (add (len $input) -1) $idx }}, {{ end }}{{- end }}) -> Result<(
		{{- $output := required .Output -}}
		{{- range $idx, $v := required .Output }}{{ required $v.T.SwiftType }}{{- if ne (add (len $output) -1) $idx }}, {{ end }}{{- end }}), RPCError>
{{ end }}
}

class RPC{{ required .Name | capitalize }}Server : RPCCallServer {
	private let impl: {{ required .Name | capitalize }}Server

	init(impl: {{ required .Name | capitalize }}Server) {
		self.impl = impl
	}

	func id() -> UInt64 {
		return {{ .ID }}
	}

	{{ $protoName := required .Name -}}
	{{ $protoID := required .ID -}}
	func handle(methodID: UInt64, rmsg: readableMessage) -> Result<RPCMessage, RPCError> {
		{{ if eq (len .Methods) 0 -}}
		return .failure(RPCError.protocolError)
		{{ else -}}
		guard let method = protocol{{required $protoName | capitalize }}Method(rawValue: methodID) else {
			return .failure(RPCError.protocolError)
		}

		switch method {
		{{- range required .Methods }}
		case protocol{{ required $protoName | capitalize }}Method.{{ required .Name | capitalize }}:
			return self.handle{{ required .Name | capitalize }}(rmsg)
		{{- end }}
		}
		{{- end }}
	}

	{{- range required .Methods }}

	func handle{{ required .Name | capitalize }}(_ rmsg: readableMessage) -> Result<RPCMessage, RPCError> {
		{{ if ne (len .Input) 0 -}}
		// Get the message class for the call and decode into it
		let args: {{ format "%sMethod%sCall" (required $protoName) (required .Name | capitalize) }}
		switch {{ format "%sMethod%sCall" (required $protoName) (required .Name | capitalize) }}.decode(rmsg) {
		case .success(let v):
			args = v as! {{ format "%sMethod%sCall" (required $protoName) (required .Name | capitalize) }}
		case .failure(let error):
			return .failure(error)
		}
		{{ end -}}

		// Call the user-provided implementation
		let res = self.impl.{{ required .Name }}(
				{{- $input := required .Input -}}
				{{ range $idx, $val := required .Input -}}
				{{ $val.Name }}: args.{{ $val.Name }}{{- if ne (add (len $input) -1) $idx }}, {{ end }}
				{{- end }})

		// Unpack the return Result<tuple, Error>
		switch res {
		case .success({{ if ne (len .Output) 0 }}let res{{ end }}):
			// Construct the return message
			let retarg = {{ format "%sMethod%sReturn" (required $protoName) (required .Name | capitalize) }}({{ if ne (len .Output) 0 }}res{{ end }})
			return .success(retarg)
		case .failure(let error):
			return .failure(error)
		}
	}
	{{- end }}
}
{{- end }}



{{- /*                    */ -}}
{{- /* Client definitions */ -}}
{{- /*                    */ -}}

{{- range required .Protocols }}

// The RPC{{ required .Name | capitalize }}Client type is a RPC client for the {{ required .Name }} protocol.
class RPC{{ required .Name | capitalize }}Client {
	let conn: RPCConnection

	init(conn: RPCConnection) {
		self.conn = conn
	}

	{{- $protoName := required .Name -}}
	{{- $protoID := required .ID -}}
	{{- range required .Methods }}

	func {{ required .Name }}(
		{{- $input := required .Input }}
		{{- range $idx, $v := required .Input }}{{ required $v.Name}}: {{ required $v.T.SwiftType }}, {{ end }}callback: @escaping (Result<(
		{{- $output := required .Output }}{{- range $idx, $v := required .Output }}{{ required $v.T.SwiftType }}{{- if ne (add (len $output) -1) $idx }}, {{ end }}
		{{- end }}), Error>) -> ()) {

		if self.conn.connectionState == .disconnected {
			callback(.failure(RPCError.connectionError))
			return ()
		}

		// Names prefixed with __rpckit2 to avoid argument name collisions

		let __rpckit2_callID = self.conn.acquireCallSlot(callback: { (rmsg) -> Result<Void, RPCError> in
			guard let resultTypeID = try? rmsg.readVarUInt().get() else {
				callback(.failure(RPCError.protocolError))
				return .failure(RPCError.protocolError)
			}
			switch resultTypeID {
			case protocol{{ required $protoName | capitalize }}Method.{{ required .Name | capitalize }}.rawValue:
				switch {{ format "%sMethod%sReturn" (required $protoName) (required .Name | capitalize) }}.decode(rmsg) {
				case .success({{ if ne (len .Output) 0 }}let v{{ else }}_{{ end }}):
					{{- if ne (len .Output) 0 }}
					let ret = v as! {{ format "%sMethod%sReturn" (required $protoName) (required .Name | capitalize) }}
					callback(.success(({{- $output := required .Output }}{{- range $idx, $v := required .Output }}ret.{{ required .Name }}{{- if ne (add (len $output) -1) $idx }}, {{ end }}{{ end }})))
					{{- else }}
					callback(.success(()))
					{{- end }}
					return .success(())
				case .failure(let error):
					callback(.failure(error))
					return .failure(error)
				}
			case UInt64.max:
				switch rpcError.decode(rmsg) {
				case .success(let v):
					let ret = v as! rpcError
					callback(.failure(RPCError.applicationError(ret.error)))
					return .success(())
				case .failure(let error):
					callback(.failure(error))
					return .failure(error)
				}
			default:
				callback(.failure(RPCError.protocolError))
				return .failure(RPCError.protocolError)
			}
		})

		let __rpckit2_wmsg = writableMessage()

		// Write the protocol header
		__rpckit2_wmsg.writeVarUInt(value: RPCMessageType.methodCall.rawValue)
		__rpckit2_wmsg.writeVarUInt(value: __rpckit2_callID)
		__rpckit2_wmsg.writeVarUInt(value: {{ required $protoID }})
		__rpckit2_wmsg.writeVarUInt(value: protocol{{ required $protoName | capitalize }}Method.{{ required .Name }}.rawValue)
		{{- if ne (len .Input) 0 }}

		let __rpckit2_callarg = {{ format "%sMethod%sCall" (required $protoName) (required .Name | capitalize) }}((
					{{- $input := required .Input -}}
					{{- range $idx, $val := required .Input -}}
					{{ $val.Name }}{{- if ne (add (len $input) -1) $idx }}, {{ end }}
					{{- end }}))
		if case .failure(let error) = __rpckit2_callarg.encode(__rpckit2_wmsg) {
			callback(.failure(error))
			return ()
		}
		{{- end }}

		__rpckit2_wmsg.finish()

		self.conn.send(wmsg: __rpckit2_wmsg)
	}

{{ end }}
}
{{ end }}



{{- /*                       */}}
{{- /* Message serialization */}}
{{- /*                       */}}

class rpcError : RPCMessage {
	fileprivate var error: String
	private var errorType: RPCErrorType

	init() {
		self.error = ""
		self.errorType = .generic
	}

	init(_ args: (String, RPCErrorType)) {
		(self.error, self.errorType) = args
	}

	func id() -> UInt64 {
		return UInt64.max
	}

	func encode(_ wmsg: writableMessage) -> Result<(), RPCError> {
		wmsg.writePBUInt64(fieldNumber: 1, value: self.errorType.rawValue)
		wmsg.writePBString(fieldNumber: 2, value: self.error)
		return .success(())
	}

	static func decode(_ rmsg: readableMessage) -> Result<RPCMessage, RPCError> {
		var error: String = ""
		var errorType: RPCErrorType = .generic
		do {
			while true {
				let tag = try rmsg.readVarUInt().get()
				switch tag {
				case (1 << 3 | RPCWireType.varInt.rawValue):
					let rv = try! rmsg.readVarUInt().get()
					guard let v = RPCErrorType(rawValue: rv) else {
						return .failure(.protocolError)
					}
					errorType = v
					break
				case (2 << 3 | RPCWireType.lengthDelimited.rawValue):
					error = try rmsg.readString().get()
					break
				default:
					try rmsg.readPBSkip(tag: tag).get()
					break
				}
			}
		} catch RPCError.eof {
		} catch let error as RPCError {
			return .failure(error)
		} catch {
			return .failure(RPCError.protocolError)
		}
		return .success(rpcError((error, errorType)))
	}
}



{{- define "swift-pb/serialization" -}}
{{- /* (De-)Serialization of messages */ -}}
{{- $typeName := required .TypeName -}}
{{- if eq (len .Fields) 0 -}}
{{- /*  Pretty implementation of message with 0 args */ -}}

fileprivate class {{ required $typeName }} : RPCMessage {
	init() {}
	func encode(_ wmsg: writableMessage) -> Result<(), RPCError> { return .success(()) }
	static func decode(_ rmsg: readableMessage) -> Result<RPCMessage, RPCError> { return .success({{ required $typeName }}()) }
	{{ if .TypeID -}}
	func id() -> UInt64 { return {{ required .TypeID }} }
	{{- end }}
}

{{- else -}}
{{- /*  Arbitrary argument implementation */ -}}

fileprivate class {{ required $typeName }} : RPCMessage {
	{{- range required .Fields }}
	var {{ required .Name }}: {{ .T.SwiftType }}
	{{- end }}

	init() {
		{{- range required .Fields }}
		self.{{ required .Name }} = {{ required .T.SwiftDefault }}
		{{- end }}
	}

	init(_ args: (
		{{- $fields := required .Fields -}}
		{{- range $idx, $v := required .Fields }}{{ required $v.T.SwiftType }}{{- if ne (add (len $fields) -1) $idx }}, {{ end }}{{- end -}})) {
		({{- $fields := required .Fields}}{{- range $idx, $v := required .Fields }}self.{{ required $v.Name }}{{- if ne (add (len $fields) -1) $idx }}, {{ end }}{{ end }}) = args
	}

	{{ if .TypeID -}}
	func id() -> UInt64 {
		return {{ required .TypeID }}
	}
	{{- end }}

	func encode(_ __rpckit2_wmsg: writableMessage) -> Result<(), RPCError> {
		// Write the auto-generated message
		{{- range required .Fields }}
		{{- $accessor := format "self.%s" (required .Name) }}
{{ template "swift-pb/marshal" dict "Field" .T "Accessor" $accessor  "Message" "__rpckit2_wmsg" "ID" .ID "ProtoName" $.ProtoName }}
		{{- end }}
		return .success(())
	}

	static func decode(_ __rpckit2_rmsg: readableMessage) -> Result<RPCMessage, RPCError> {
		{{ if eq (len .Fields) 1 -}}{{ range required .Fields }}var args: {{ .T.SwiftType }} = {{ .T.SwiftDefault }}{{ end }}
		{{- else -}}
		var args: ({{- $fields := required .Fields}}{{- range $idx, $v := required .Fields }}{{ required $v.Name }}: {{ required $v.T.SwiftType }}{{- if ne (add (len $fields) -1) $idx }}, {{ end }}{{ end }}) = ({{- $fields := required .Fields}}{{- range $idx, $v := required .Fields }}{{ required $v.T.SwiftDefault }}{{- if ne (add (len $fields) -1) $idx }}, {{ end }}{{ end }})
		{{- end }}
		do {
			while true {
				{{- if eq (len .Fields) 1 -}}
				{{- $accessor := "args" }}
				{{- range .Fields }}
				if (try __rpckit2_rmsg.readVarUInt().get() == {{ required .ID }} << 3 | {{ if .T.IsArray }}{{ template "swift-pb/property-to-wiretype" .T.InnerValue.String}}{{ else if .T.IsMarshalled}}{{ template "swift-pb/property-to-wiretype" "String"}}{{ else }}{{ template "swift-pb/property-to-wiretype" .T.String}}{{ end }}.rawValue) {
{{ template "swift-pb/unmarshal" dict "Field" .T "Accessor" $accessor "Message" "__rpckit2_rmsg" "ProtoName" $.ProtoName }}
				} else {
					return .failure(RPCError.protocolError)
				}
				{{- end }}
				{{- else }}
				let tag = try __rpckit2_rmsg.readVarUInt().get()
				switch tag {
				{{- range .Fields }}
				{{- $accessor := format "args.%s" (required .Name) }}
				case ({{ required .ID }} << 3 | {{ if .T.IsArray }}{{ template "swift-pb/property-to-wiretype" .T.InnerValue.String}}{{ else if .T.IsMarshalled}}{{ template "swift-pb/property-to-wiretype" "String"}}{{ else }}{{ template "swift-pb/property-to-wiretype" .T.String}}{{ end }}.rawValue):
{{ template "swift-pb/unmarshal" dict "Field" .T "Accessor" $accessor "Message" "__rpckit2_rmsg" "ProtoName" $.ProtoName }}
					break
				{{- end }}
				default:
					try __rpckit2_rmsg.readPBSkip(tag: tag).get()
					break
				}
				{{- end }}
			}
		} catch RPCError.eof {
			// Not a problem
		} catch let error as RPCError {
			return .failure(error)
		} catch {
			return .failure(RPCError.protocolError)
		}
		return .success({{ required $typeName }}(args))
	}
}
{{- end -}}
{{- end -}}

{{ range required .Protocols }}
{{ range required .Structs }}
{{ $struct_name := .Name }}
// {{ required .Description | capitalize }}
public class {{ required .Name | capitalize }} {
{{- range required .Fields }}
	{{- if .Description }}
	// {{ required .Description | capitalize }}
	{{ end }}
	public var {{ required .Name | capitalize }}: {{ .T.SwiftType }} = {{ .T.SwiftDefault }}
{{- end }}
}

{{ end }}
{{ end }}


{{- define "swift-pb/serialization-struct" -}}
{{- /* (De-)Serialization of messages */ -}}
{{- $typeName := required .TypeName -}}
{{- if eq (len .Fields) 0 -}}
{{- /*  Pretty implementation of message with 0 args */ -}}

fileprivate class {{ required $typeName }} : RPCMessage {
	var s: {{ required .Name | capitalize }}
	init() {}
	func encode(_ wmsg: writableMessage) -> Result<(), RPCError> { return .success(()) }
	static func decode(_ rmsg: readableMessage) -> Result<RPCMessage, RPCError> { return .success({{ required $typeName }}()) }
	{{ if .TypeID -}}
	func id() -> UInt64 { return {{ required .TypeID }} }
	{{- end }}
}

{{- else -}}
{{- /*  Arbitrary argument implementation */ -}}

fileprivate class {{ required $typeName }} : RPCMessage {
	fileprivate var v: {{ required .Name | capitalize }}

	init(_ arg: {{ required .Name | capitalize }}) {
		v = arg
	}

	func id() -> UInt64 {
		return 0
	}

	func encode(_ __rpckit2_wmsg: writableMessage) -> Result<(), RPCError> {
		// Write the auto-generated message
		{{- range required .Fields }}
		{{- $accessor := format "self.v.%s" (required .Name | capitalize) }}
{{ template "swift-pb/marshal" dict "Field" .T "Accessor" $accessor  "Message" "__rpckit2_wmsg" "ID" .ID "ProtoName" $.ProtoName }}
		{{- end }}
		return .success(())
	}

	static func decode(_ __rpckit2_rmsg: readableMessage) -> Result<RPCMessage, RPCError> {
		let args: {{ required .Name | capitalize }} = {{ required .Name | capitalize }}()
		do {
			while true {
				let tag = try __rpckit2_rmsg.readVarUInt().get()
				switch tag {
				{{- range .Fields }}
				{{- $accessor := format "args.%s" (required .Name | capitalize) }}
				case ({{ required .ID }} << 3 | {{ if .T.IsArray }}{{ template "swift-pb/property-to-wiretype" .T.InnerValue.String}}{{ else if .T.IsMarshalled}}{{ template "swift-pb/property-to-wiretype" "String"}}{{ else }}{{ template "swift-pb/property-to-wiretype" .T.String}}{{ end }}.rawValue):
{{ template "swift-pb/unmarshal" dict "Field" .T "Accessor" $accessor "Message" "__rpckit2_rmsg" "ProtoName" $.ProtoName }}
					break
				{{- end }}
				default:
					return .failure(RPCError.protocolError)
				}
			}
		} catch RPCError.eof {
			// Not a problem
		} catch let error as RPCError {
			return .failure(error)
		} catch {
			return .failure(RPCError.protocolError)
		}
		return .success({{ required $typeName }}(args))
	}
}
{{- end -}}
{{- end -}}


{{- define "swift-pb/serialization-map" -}}
{{- /* (De-)Serialization of messages */ -}}
{{ if .T.IsArray }}
{{ template "swift-pb/serialization-map" dict "T" .T.InnerValue "ProtoName" .ProtoName }}
{{ else if .T.IsMap }}
{{ template "swift-pb/serialization-map" dict "T" .T.InnerKey "ProtoName" .ProtoName }}
{{ template "swift-pb/serialization-map" dict "T" .T.InnerValue "ProtoName" .ProtoName }}
{{ $name := format "rpcMapKey%sValue%s" .T.InnerKey .T.InnerValue }}
{{ if ifnotexists (format "rpcMap%s" .T.SwiftType) }}
{{ store (format "rpcMap-%s" .T.SwiftType) $name }}
fileprivate class {{ required $name }} : RPCMessage {
	fileprivate var key: {{ required .T.InnerKey.SwiftType }}
	fileprivate var value: {{ required .T.InnerValue.SwiftType }}

	init() {
		self.key = {{ required .T.InnerKey.SwiftDefault }}
		self.value = {{ required .T.InnerValue.SwiftDefault }}
	}

	init(_ key: {{ required .T.InnerKey.SwiftType}}, _ value: {{ required .T.InnerValue.SwiftType}}) {
		self.key = key
		self.value = value
	}

	func id() -> UInt64 {
		return 0
	}

	func encode(_ __rpckit2_wmsg: writableMessage) -> Result<(), RPCError> {
		// Write the auto-generated message
{{ template "swift-pb/marshal" dict "Field" .T.InnerKey "Accessor" "self.key" "Message" "__rpckit2_wmsg" "ID" 1 "ProtoName" .ProtoName }}
{{ template "swift-pb/marshal" dict "Field" .T.InnerValue "Accessor" "self.value" "Message" "__rpckit2_wmsg" "ID" 2 "ProtoName" .ProtoName }}
		return .success(())
	}

	static func decode(_ __rpckit2_rmsg: readableMessage) -> Result<RPCMessage, RPCError> {
		var key: {{ required .T.InnerKey.SwiftType }} = {{ required .T.InnerKey.SwiftDefault }}
		var value: {{ required .T.InnerValue.SwiftType }} = {{ required .T.InnerValue.SwiftDefault }}
		do {
			while true {
				let tag = try __rpckit2_rmsg.readVarUInt().get()
				switch tag {
				case (1 << 3 | {{ if .T.InnerKey.IsMarshalled }}{{ template "swift-pb/property-to-wiretype" "String"}}{{ else }}{{ template "swift-pb/property-to-wiretype" .T.InnerKey.String }}{{ end }}.rawValue):
{{ template "swift-pb/unmarshal" dict "Field" .T.InnerKey "Accessor" "key" "Message" "__rpckit2_rmsg" "ProtoName" .ProtoName }}
				case (2 << 3 | {{ if .T.InnerValue.IsMarshalled }}{{ template "swift-pb/property-to-wiretype" "String"}}{{ else }}{{ template "swift-pb/property-to-wiretype" .T.InnerValue.String }}{{ end }}.rawValue):
{{ template "swift-pb/unmarshal" dict "Field" .T.InnerValue "Accessor" "value" "Message" "__rpckit2_rmsg" "ProtoName" .ProtoName }}
					break
				default:
					return .failure(RPCError.protocolError)
				}
			}
		} catch RPCError.eof {
			// Not a problem
		} catch let error as RPCError {
			return .failure(error)
		} catch {
			return .failure(RPCError.protocolError)
		}
		return .success({{ required $name }}(key, value))
	}
}
{{- end -}}
{{- end -}}
{{- end -}}

{{ range required .Protocols }}
{{- $protoName := required .Name -}}
{{- $protoID := required .ID -}}
{{ range required .Structs }}
{{ if ifnotexists (format "rpcGlobalStruct%s" (required .Name | capitalize)) -}}
{{ range required .Fields }}
{{ template "swift-pb/serialization-map" dict "T" .T "ProtoName" $protoName }}
{{ end }}
{{ template "swift-pb/serialization-struct" dict "TypeName" (format "rpcGlobalStruct%s" (required .Name | capitalize)) "Name" .Name "Fields" .Fields "ProtoName" $protoName }}
{{- end }}
{{ end }}
{{ range required .Methods }}
{{ range required .Input }}
{{ template "swift-pb/serialization-map" dict "T" .T "ProtoName" $protoName }}
{{ end }}
{{ range required .Output }}
{{ template "swift-pb/serialization-map" dict "T" .T "ProtoName" $protoName }}
{{ end }}
{{ end }}
{{ end }}

{{ range required .Protocols }}
	{{- $protoName := required .Name -}}
	{{- $protoID := required .ID -}}
	{{ range required .Methods }}
		{{- $typeID := format "protocol%sMethod.%s.rawValue" (capitalize $protoName) (capitalize .Name)}}
{{ template "swift-pb/serialization" dict "TypeName" (format "%sMethod%sCall" (required $protoName) (required .Name | capitalize)) "TypeID" $typeID "Fields" .Input "ProtoName" $protoName }}
{{ template "swift-pb/serialization" dict "TypeName" (format "%sMethod%sReturn" (required $protoName) (required .Name | capitalize)) "TypeID" $typeID "Fields" .Output "ProtoName" $protoName }}
	{{ end }}
{{ end }}
