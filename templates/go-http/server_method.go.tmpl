// HTTP{{ required .ProtoName | capitalize }}Server creates a new HTTPServer for the {{ required .ProtoName }} protocol.
func HTTP{{ required .ProtoName | capitalize }}Server(methods {{ required .ProtoName | capitalize }}Protocol) HTTPServer {
    return &httpCallServerFor{{ required .ProtoName | capitalize }}{methods: methods}
}

type httpCallServerFor{{ required .ProtoName | capitalize }} struct {
    methods {{ required .ProtoName | capitalize }}Protocol
}

func (c *httpCallServerFor{{ required .ProtoName | capitalize }}) RegisterToMux(m *http.ServeMux) {
    {{- $protoName := required .ProtoName }}
    {{- range required .Methods }}
    m.HandleFunc("/{{ required $protoName }}/{{ required .Name | lower }}", func(w http.ResponseWriter, r *http.Request) {
        {{- if gt (len .Input) 0 }}
        if r.Method != "POST" {
            w.WriteHeader(http.StatusMethodNotAllowed)
            return
        }

        {{ end -}}

        var (
            err error
            b []byte
            {{ if gt (len .Input) 0 }}reqbody httpReqProto{{ required $protoName | capitalize }}Method{{ required .Name | capitalize }}{{ end }}
            {{ if gt (len .Output) 0 }}respbody httpRespProto{{ required $protoName | capitalize }}Method{{ required .Name | capitalize }}{{ end }}
        )

        b, err = ioutil.ReadAll(r.Body)
        if err != nil {
            w.WriteHeader(http.StatusBadRequest)
            return
        }

        {{- if gt (len .Input) 0 }}
        {{ if and (eq (len .Input) 1) (eq (index .Input 0).T.GoType "[]byte") }}
        reqbody.{{ required (index .Input 0).Name | capitalize}} = b
        {{ else }}
        if err = json.Unmarshal(b, &reqbody); err != nil {
            w.WriteHeader(http.StatusBadRequest)
            return
        }
        {{ end }}
        {{ else }}
        if len(b) > 0 {
            w.WriteHeader(http.StatusBadRequest)
            return
        }
        {{ end }}

        {{- $methodName := required .Name }}
        {{ range .Output }}respbody.{{ required .Name | capitalize }}, {{ end }}err = c.methods.{{ required .Name | capitalize }}(r.Context(){{- range .Input }}, reqbody.{{ required .Name | capitalize }}{{- end }})
        if err != nil {
			if header,ok := err.(interface{StatusCode() int}); ok {
				w.WriteHeader(header.StatusCode())
			} else {
           		w.WriteHeader(http.StatusInternalServerError)
			}

            errorbody := struct {
                Error interface {} `json:"error"`
            }{
                Error: err,
            }
            if b, err = json.Marshal(&errorbody); err != nil {
                return
            }

            w.Header().Set("Content-Type", "application/json")
            w.Write(b)
            return
        }

        {{- if gt (len .Output) 0 }}
        {{ if and (eq (len .Output) 1) (eq (index .Output 0).T.GoType "[]byte") }}
        b = respbody.{{ required (index .Output 0).Name | capitalize }}
        {{ else }}
        if b, err = json.Marshal(&respbody); err != nil {
            w.WriteHeader(http.StatusInternalServerError)
            // TODO: Add error!
            return
        }
        {{ end }}
        {{ else }}
        b = nil
        {{ end }}

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        w.Write(b)
    })
    {{- end }}
}
