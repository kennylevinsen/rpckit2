{{ range required .Protocols }}
{{ $protoName := required .Name -}}
{{ range required .Methods }}
func (args *rpcReqProto{{ required $protoName | capitalize }}Method{{ required .Name | capitalize }}) call(ctx context.Context, s rpcCallServer) (resp rpcMessage) {
    {{ range .Output }}{{ .Name }}, {{ end }}err := s.(*rpcCallServerFor{{ required $protoName | capitalize }}).methods.{{ required .Name | capitalize }}(ctx{{- range .Input }}, args.{{ required .Name | capitalize }}{{- end }})
    if err != nil {
        if rpcMsg, ok := err.(rpcMessage); ok {
            return rpcMsg
        }
        return &rpcError{id: ApplicationError, error: err.Error()}
    }
    return &rpcRespProto{{ required $protoName | capitalize }}Method{{ required .Name | capitalize }}{
        {{- range required .Output }}
        {{ required .Name | capitalize }}: {{ required .Name }},
        {{- end }}
    }
}
{{ end }}

func (s *rpcCallServerFor{{ required .Name | capitalize }}) handle(ctx context.Context, methodID uint64, m *message) (callable rpcCallable, err error) {
    switch methodID {
    {{- range required .Methods }}
    case uint64(proto{{ required $protoName | capitalize }}Method{{ required .Name | capitalize }}):
        args := rpcReqProto{{ required $protoName | capitalize }}Method{{ required .Name | capitalize }}{}
        if err := args.RPCDecode(m); err != nil {
            return nil, fmt.Errorf("unable to decode method call: %v", err)
        }
        return &args, nil
    {{- end }}
    default:
        return nil, fmt.Errorf("unknown method ID: %d", methodID)
    }
}
{{ end }}
